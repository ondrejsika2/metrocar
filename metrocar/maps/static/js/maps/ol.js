// Generated by CoffeeScript 1.3.1
(function() {
  var __slice = [].slice;

  requirejs.config({
    paths: {
      OpenLayers: 'http://openlayers.org/api/OpenLayers'
    },
    shim: {
      OpenLayers: {
        exports: 'OpenLayers'
      }
    }
  });

  define(['jquery', 'OpenLayers', 'maps/utils'], function($, OpenLayers, utils) {
    var Control, Feature, Geometry, Icon, Layer, Map, Marker, OLTransformType, Popup, Projection, Style, StyleMap, WSG84, createMap, createPopup, styleMap;
    Control = OpenLayers.Control, Feature = OpenLayers.Feature, Geometry = OpenLayers.Geometry, Icon = OpenLayers.Icon, Layer = OpenLayers.Layer, Map = OpenLayers.Map, Marker = OpenLayers.Marker, Popup = OpenLayers.Popup, Projection = OpenLayers.Projection, Style = OpenLayers.Style, StyleMap = OpenLayers.StyleMap;
    WSG84 = new Projection("EPSG:4326");
    styleMap = new StyleMap({
      "default": new Style({
        strokeColor: "#F80101",
        strokeWidth: 5,
        graphicZIndex: 1
      }),
      select: new Style({
        fillColor: "#66ccff",
        strokeColor: "#3399ff",
        graphicZIndex: 2
      })
    });
    OLTransformType = function(T, projection) {
      return function() {
        var args, obj;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        obj = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args), t = typeof result;
          return t == "object" || t == "function" ? result || child : child;
        })(T, args, function(){});
        obj.transform(WSG84, projection);
        return obj;
      };
    };
    createPopup = function(map, location, content) {
      var markerPopup;
      markerPopup = new Popup.FramedCloud("popup", location, null, content, null, true, function() {
        return this.destroy();
      });
      return map.addPopup(markerPopup, true);
    };
    createMap = function(container) {
      var API, Bounds, LonLat, Point, iconMarkerLayer, map, mapProjection, markerLayer, markerPopup, markerSelect, osmLayer, routeLayer, typeConstructor;
      console.log('initializing OL map in', container);
      map = new Map();
      map.addLayer(osmLayer = new Layer.OSM());
      map.zoomToMaxExtent();
      map.render(container);
      window.themap = map;
      mapProjection = map.getProjectionObject();
      typeConstructor = function(T) {
        return OLTransformType(T, mapProjection);
      };
      Point = typeConstructor(OpenLayers.Geometry.Point);
      LonLat = typeConstructor(OpenLayers.LonLat);
      Bounds = typeConstructor(OpenLayers.Bounds);
      markerPopup = null;
      map.addLayer(routeLayer = new Layer.Vector("Route", {
        styleMap: styleMap,
        rendererOptions: {
          zIndexing: true
        }
      }));
      map.addLayer(markerLayer = new Layer.Vector("Markers", {
        rendererOptions: {
          zIndexing: true
        }
      }));
      map.addControl(markerSelect = new Control.SelectFeature(markerLayer, {
        hover: true
      }));
      markerSelect.events.register('featurehighlighted', map, function(_arg) {
        var content, feature, location;
        feature = _arg.feature;
        location = feature.geometry.getBounds().getCenterLonLat();
        content = feature.attributes.content;
        return createPopup(map, location, content);
      });
      map.addLayer(iconMarkerLayer = new Layer.Markers("IconMarkers", {
        rendererOptions: {
          zIndexing: true
        }
      }));
      return API = {
        onMoved: function(callback) {
          return map.events.register('moveend', map, function() {
            return callback(API.getBounds());
          });
        },
        getBounds: function() {
          var bounds;
          bounds = map.getExtent();
          bounds.transform(mapProjection, WSG84);
          return bounds;
        },
        setBounds: function(_arg) {
          var bottom, left, right, top;
          left = _arg.left, bottom = _arg.bottom, right = _arg.right, top = _arg.top;
          return map.zoomToExtent(Bounds(left, bottom, right, top));
        },
        drawRoute: function(route) {
          var line, points, routeFeature;
          points = route.map(function(_arg) {
            var x, y;
            x = _arg[0], y = _arg[1];
            return Point(x, y);
          });
          line = new Geometry.MultiLineString(points.slice(0, -1).map(function(point, i) {
            return new Geometry.LineString([point, points[i + 1]]);
          }));
          routeFeature = new Feature.Vector(line);
          return routeLayer.addFeatures([routeFeature]);
        },
        drawMarker: function(_arg) {
          var content, location, marker, point;
          location = _arg.location, content = _arg.content;
          point = Point.apply(null, location);
          marker = new Feature.Vector(point, {
            content: content
          });
          markerLayer.addFeatures([marker]);
          return markerSelect.activate();
        },
        drawIconMarker: function(_arg) {
          var content, icon, location, marker, offset, size, _icon, _location, _offset, _size;
          location = _arg.location, content = _arg.content, icon = _arg.icon, size = _arg.size, offset = _arg.offset;
          /*
                  content: HTML content of a pop-up
                  icon: URL to icon image
                  size: [x, y] pixels
                  offset: (optional) [x, y] pixels
          */

          _size = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args), t = typeof result;
            return t == "object" || t == "function" ? result || child : child;
          })(OpenLayers.Size, size, function(){});
          _offset = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args), t = typeof result;
            return t == "object" || t == "function" ? result || child : child;
          })(OpenLayers.Pixel, offset || [-size[0] / 2, -size[1]], function(){});
          _icon = new OpenLayers.Icon(icon, _size, _offset);
          _location = LonLat.apply(null, location);
          iconMarkerLayer.addMarker(marker = new Marker(_location, _icon));
          return marker.events.register('click', map, function() {
            return createPopup(map, _location, content);
          });
        },
        drawMarkers: function(markers) {
          var m, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = markers.length; _i < _len; _i++) {
            m = markers[_i];
            _results.push(this.drawMarker(m));
          }
          return _results;
        },
        clear: function() {
          if (markerPopup) {
            map.removePopup(markerPopup);
          }
          routeLayer.removeAllFeatures();
          markerLayer.removeAllFeatures();
          return iconMarkerLayer.clearMarkers();
        },
        focus: function(locations) {
          console.log('OLMap focus called with', locations);
          return API.setBounds(utils.polygonToBounds(locations));
        }
      };
    };
    return {
      createMap: createMap
    };
  });

}).call(this);
